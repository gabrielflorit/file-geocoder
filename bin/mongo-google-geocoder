#!/usr/bin/env node

var fs = require('fs');
var optimist = require('optimist');
var mongo = require('mongodb');
var geocoder = require('geocoder');
var _ = require('lodash');
var sleep = require('sleep');

var argv = optimist
	.usage('Geocode a MongoDB collection. Talks to a Google-style geocoder.\nUsage: $0')
	.options('d', {
		demand: true,
		alias: 'database',
		describe: 'the MongoDB database'
	})
	.options('c', {
		demand: true,
		alias: 'collection',
		describe: 'the MongoDB collection'
	})
	.options('f', {
		demand: true,
		alias: 'fields',
		describe: 'a comma-separated list of address fields, in order'
	})
	.options('h', {
		demand: false,
		alias: 'host',
		describe: 'the geocoder host',
		default: 'localhost'
	})
	.options('p', {
		demand: false,
		alias: 'port',
		describe: 'the geocoder port',
		default: 8080
	})
	.options('s', {
		demand: false,
		alias: 'connection',
		describe: 'the MongoDB connection string',
		default: 'mongodb://127.0.0.1:27017/'
	})
	.options('t', {
		demand: false,
		alias: 'throttle',
		describe: 'time (in seconds) to throttle the geocoding requests.',
		default: 0
	})
	.argv;

var MongoClient = mongo.MongoClient;

var summary = [];

MongoClient.connect(argv.connection + argv.database, function(err, db) {

	var collection = db.collection(argv.collection);
	var counter = 0;

	collection.find({Geocode:{$exists:false}}).count(function(err, count) {

		if (count > 0) {

			// tell pace how many elements we're going to process
			var pace = require('pace')({
				total: count,
				itemType: 'documents'
			});

			collection.find({Geocode:{$exists:false}}).each(function(err, doc) {

				if (doc) {

					// create the address
					var address = argv.fields.split(',').map(function(value) {
						return doc[value];
					}).join(', ');

					geocoder.geocode(address, function (err, data) {

						var status = data.status;
						var updates = {};
						var locality = '';
						var administrative_area_level_1 = '';
						var country = '';

						try {

							if (status === 'ZERO_RESULTS') {
							} else {

								status = data.results[0].geometry.location_type;
								var coords = data.results[0].geometry.location;
								updates = {lat: coords.lat, lng: coords.lng};

								// find the locality
								locality = _(data.results[0].address_components)
									.filter(function(v) {
										return _.contains(v.types, 'locality');
									})
									.first(1)
									.pluck('long_name')
									.value();

								// find the administrative_area_level_1
								administrative_area_level_1 = _(data.results[0].address_components)
									.filter(function(v) {
										return _.contains(v.types, 'administrative_area_level_1');
									})
									.first(1)
									.pluck('long_name')
									.value();

								// find the country
								country = _(data.results[0].address_components)
									.filter(function(v) {
										return _.contains(v.types, 'country');
									})
									.first(1)
									.pluck('long_name')
									.value();
							}
						} catch(e) {
							console.log(JSON.stringify(data, null, 4));
							throw e;
						}

						summary.push(status);
						updates.Geocode = data;
						updates.GeocodeStatus = status;
						updates.GeocodeLocality = locality;
						updates.GeocodeAdminAreaLevel1 = administrative_area_level_1;
						updates.GeocodeCountry = country;
						updates.FullAddress = address;

						collection.update({_id:doc._id}, {$set:updates}, function(err, inserted) {

							counter++;

							pace.op(counter);
							sleep.sleep(argv.throttle);

							if (counter >= count) {
								db.close();
								console.log("Summary:");
								console.log(JSON.stringify(_.countBy(summary, function(v) { return v; }), null, 2));
							}

						});

					}, {}, argv.host, argv.port);

				}

			});

		} else {
			console.log('All documents have been geocoded.');
			db.close();
		}

	});

});
